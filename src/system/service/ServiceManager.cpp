//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : OPRoS Component
//  @ File Name : ServiceManager.cpp
//  @ Date : 2008-08-22
//  @ Author :
//
//

#include <string>

#include "modconfig/ModConfig.h"

#include "ServiceManager.h"
#ifdef MOD_OPROS_SERVICEMANAGER_USE_CONSOLE
#include "ext/ServiceConsole.h"
#endif
#ifdef MOD_OPROS_SERVICEMANAGER_USE_TASK
#include "task/TaskModelBinder.h"
#endif


class ServiceManagerProvider
{
	typedef std::map<std::string, Service *> ServiceMap;	
	ServiceMap m_serviceMap;
	ServiceManager *m_host;

#ifdef MOD_OPROS_SERVICEMANAGER_USE_CONSOLE
	ServiceConsole *m_requester;
#endif

#ifdef MOD_OPROS_SERVICEMANAGER_USE_TASK
	TaskModelBinder m_binder;
#endif

public:
	ServiceManagerProvider(ServiceManager *host) : m_host(host)
	{
#ifdef MOD_OPROS_SERVICEMANAGER_USE_TASK
		setService("task",&m_binder);
#endif

#ifdef MOD_OPROS_SERVICEMANAGER_USE_CONSOLE
		m_requester = new ServiceConsole();
#endif
	}

	virtual ~ServiceManagerProvider()
	{
		ServiceMap::iterator it = m_serviceMap.begin();
		for (;it != m_serviceMap.end(); ++it)
		{
			Service *p = it->second;
			if (p->getDestroyFlag()) delete p;
		}

		m_serviceMap.clear();
#ifdef MOD_OPROS_SERVICEMANAGER_USE_CONSOLE
		delete m_requester;
#endif
	}
	

	void setService(const std::string &name, Service *pservice)
	{
		if (pservice==NULL) return;

		if (m_host->getState() == MS_DESTROYED) return;

		if (m_serviceMap.count(name) != 0)
		{
			Service *p = m_serviceMap[name];

			if (p->getDestroyFlag()) delete p;
		}

		m_serviceMap[name] = pservice;

		switch (m_host->getState())
		{
		
			case MS_INITED: 
				pservice->init();
				break;
			case MS_STARTED: 
				pservice->init();
				pservice->start();
				break;
			
			case MS_STOPPED:
				pservice->stop();

			default:;
		}

	}

	Service *getService(const std::string &name)
	{
		ServiceMap::iterator it = m_serviceMap.find(name);
		if (it != m_serviceMap.end())
			return it->second;

		return NULL;	
	}

	bool onInit()
	{
#ifdef MOD_OPROS_SERVICEMANAGER_USE_CONSOLE
		m_requester->open("service");
#endif

		ServiceMap::iterator it = m_serviceMap.begin();
		for (;it != m_serviceMap.end(); ++it)
		{
			Service *p = it->second;
			p->init();
		}

		return true;
	}

	bool onStart()
	{
		ServiceMap::iterator it = m_serviceMap.begin();
		for (;it != m_serviceMap.end(); ++it)
		{
			Service *p = it->second;
			p->start();
		}
		return true;
	}

	bool onStop()
	{
#ifdef MOD_OPROS_SERVICEMANAGER_USE_CONSOLE
		m_requester->close();
#endif

		ServiceMap::iterator it = m_serviceMap.begin();
		for (;it != m_serviceMap.end(); ++it)
		{
			Service *p = it->second;
			p->stop();
		}
		return true;
	}

	bool onDestroy()
	{
		ServiceMap::iterator it = m_serviceMap.begin();
		for (;it != m_serviceMap.end(); ++it)
		{
			Service *p = it->second;
			p->destroy();
		}
		return true;
	}
};


void ServiceManager::setService(const std::string &name, Service *service) {
	
	if (m_provider != NULL)
		m_provider->setService(name, service);
	
}

Service *ServiceManager::getService(const std::string &name) {
	if (m_provider == NULL) return NULL;

	return m_provider->getService(name);
}

ServiceManager::ServiceManager()
{
	m_provider = new ServiceManagerProvider(this);	
}

ServiceManager::~ServiceManager()
{
	
	delete m_provider;
}

bool ServiceManager::onInit()
{	

	if (m_provider == NULL) return false;

	return m_provider->onInit();
}

bool ServiceManager::onStart()
{
	if (m_provider == NULL) return false;

	return m_provider->onStart();
}

bool ServiceManager::onStop()
{

	if (m_provider == NULL) return false;

	return m_provider->onStop();
}

bool ServiceManager::onDestroy()
{
	if (m_provider == NULL) return false;

	return m_provider->onDestroy();
}
